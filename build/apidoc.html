<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/qiao/heap.js"

    >heap (v0.2.6)</a>
</h1>
<h4>binary heap (priority queue) algorithms (ported from Python's heapq module)</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.heap">module heap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap">
            function <span class="apidocSignatureSpan"></span>heap
            <span class="apidocSignatureSpan">(cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heapify">
            function <span class="apidocSignatureSpan">heap.</span>heapify
            <span class="apidocSignatureSpan">(array, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.nlargest">
            function <span class="apidocSignatureSpan">heap.</span>nlargest
            <span class="apidocSignatureSpan">(array, n, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.nsmallest">
            function <span class="apidocSignatureSpan">heap.</span>nsmallest
            <span class="apidocSignatureSpan">(array, n, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.pop">
            function <span class="apidocSignatureSpan">heap.</span>pop
            <span class="apidocSignatureSpan">(array, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.push">
            function <span class="apidocSignatureSpan">heap.</span>push
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.pushpop">
            function <span class="apidocSignatureSpan">heap.</span>pushpop
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.replace">
            function <span class="apidocSignatureSpan">heap.</span>replace
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.updateItem">
            function <span class="apidocSignatureSpan">heap.</span>updateItem
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">heap.</span>heap.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.heap.heap">module heap.heap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.heap">
            function <span class="apidocSignatureSpan">heap.</span>heap
            <span class="apidocSignatureSpan">(cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.heapify">
            function <span class="apidocSignatureSpan">heap.heap.</span>heapify
            <span class="apidocSignatureSpan">(array, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.nlargest">
            function <span class="apidocSignatureSpan">heap.heap.</span>nlargest
            <span class="apidocSignatureSpan">(array, n, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.nsmallest">
            function <span class="apidocSignatureSpan">heap.heap.</span>nsmallest
            <span class="apidocSignatureSpan">(array, n, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.pop">
            function <span class="apidocSignatureSpan">heap.heap.</span>pop
            <span class="apidocSignatureSpan">(array, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.push">
            function <span class="apidocSignatureSpan">heap.heap.</span>push
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.pushpop">
            function <span class="apidocSignatureSpan">heap.heap.</span>pushpop
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.replace">
            function <span class="apidocSignatureSpan">heap.heap.</span>replace
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.updateItem">
            function <span class="apidocSignatureSpan">heap.heap.</span>updateItem
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.heap.heap.prototype">module heap.heap.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.clear">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.clone">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.contains">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>contains
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.copy">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>copy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.empty">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.front">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>front
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.has">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>has
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.heapify">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>heapify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.insert">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>insert
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.peek">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.pop">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.push">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>push
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.pushpop">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>pushpop
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.replace">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>replace
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.size">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.toArray">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.top">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>top
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.heap.heap.prototype.updateItem">
            function <span class="apidocSignatureSpan">heap.heap.prototype.</span>updateItem
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.heap" id="apidoc.module.heap">module heap</a></h1>


    <h2>
        <a href="#apidoc.element.heap.heap" id="apidoc.element.heap.heap">
        function <span class="apidocSignatureSpan"></span>heap
        <span class="apidocSignatureSpan">(cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Heap(cmp) {
  this.cmp = cmp != null ? cmp : defaultCmp;
  this.nodes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heapify" id="apidoc.element.heap.heapify">
        function <span class="apidocSignatureSpan">heap.</span>heapify
        <span class="apidocSignatureSpan">(array, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heapify = function (array, cmp) {
  var i, _i, _j, _len, _ref, _ref1, _results, _results1;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  _ref1 = (function() {
    _results1 = [];
    for (var _j = 0, _ref = floor(array.length / 2); 0 &#x3c;= _ref ? _j &#x3c; _ref : _j &#x3e; _ref; 0 &#x3c;= _ref ? _j++ : _j--){ _results1.push
(_j); }
    return _results1;
  }).apply(this).reverse();
  _results = [];
  for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
    i = _ref1[_i];
    _results.push(_siftup(array, i, cmp));
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.nlargest" id="apidoc.element.heap.nlargest">
        function <span class="apidocSignatureSpan">heap.</span>nlargest
        <span class="apidocSignatureSpan">(array, n, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nlargest = function (array, n, cmp) {
  var elem, result, _i, _len, _ref;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  result = array.slice(0, n);
  if (!result.length) {
    return result;
  }
  heapify(result, cmp);
  _ref = array.slice(n);
  for (_i = 0, _len = _ref.length; _i &#x3c; _len; _i++) {
    elem = _ref[_i];
    heappushpop(result, elem, cmp);
  }
  return result.sort(cmp).reverse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
heap.pop(); // {foo: 1}
```

find 3 largest/smallest items in an array

```js
var array = [1, 3, 4, 2, 5];
Heap.<span class="apidocCodeKeywordSpan">nlargest</span>(array, 3);  // [5, 4, 3]
Heap.nsmallest(array, 3); // [1, 2, 3]
```

Document
--------

This module exposes only one object, namely the Heap class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.nsmallest" id="apidoc.element.heap.nsmallest">
        function <span class="apidocSignatureSpan">heap.</span>nsmallest
        <span class="apidocSignatureSpan">(array, n, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nsmallest = function (array, n, cmp) {
  var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  if (n * 10 &#x3c;= array.length) {
    result = array.slice(0, n).sort(cmp);
    if (!result.length) {
      return result;
    }
    los = result[result.length - 1];
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i &#x3c; _len; _i++) {
      elem = _ref[_i];
      if (cmp(elem, los) &#x3c; 0) {
        insort(result, elem, 0, null, cmp);
        result.pop();
        los = result[result.length - 1];
      }
    }
    return result;
  }
  heapify(array, cmp);
  _results = [];
  for (i = _j = 0, _ref1 = min(n, array.length); 0 &#x3c;= _ref1 ? _j &#x3c; _ref1 : _j &#x3e; _ref1; i = 0 &#x3c;= _ref1 ? ++_j : --_j) {
    _results.push(heappop(array, cmp));
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

find 3 largest/smallest items in an array

```js
var array = [1, 3, 4, 2, 5];
Heap.nlargest(array, 3);  // [5, 4, 3]
Heap.<span class="apidocCodeKeywordSpan">nsmallest</span>(array, 3); // [1, 2, 3]
```

Document
--------

This module exposes only one object, namely the Heap class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.pop" id="apidoc.element.heap.pop">
        function <span class="apidocSignatureSpan">heap.</span>pop
        <span class="apidocSignatureSpan">(array, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function (array, cmp) {
  var lastelt, returnitem;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  lastelt = array.pop();
  if (array.length) {
    returnitem = array[0];
    array[0] = lastelt;
    _siftup(array, 0, cmp);
  } else {
    returnitem = lastelt;
  }
  return returnitem;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
push and pop

```js
var heap = new Heap();
heap.push(3);
heap.push(1);
heap.push(2);
heap.<span class="apidocCodeKeywordSpan">pop</span>(); // 1
```

custom comparison function

```js
var heap = new Heap(function(a, b) {
return a.foo - b.foo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.push" id="apidoc.element.heap.push">
        function <span class="apidocSignatureSpan">heap.</span>push
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (array, item, cmp) {
  if (cmp == null) {
    cmp = defaultCmp;
  }
  array.push(item);
  return _siftdown(array, 0, array.length - 1, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
-------


push and pop

```js
var heap = new Heap();
heap.<span class="apidocCodeKeywordSpan">push</span>(3);
heap.push(1);
heap.push(2);
heap.pop(); // 1
```

custom comparison function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.pushpop" id="apidoc.element.heap.pushpop">
        function <span class="apidocSignatureSpan">heap.</span>pushpop
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushpop = function (array, item, cmp) {
  var _ref;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  if (array.length &#x26;&#x26; cmp(array[0], item) &#x3c; 0) {
    _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
    _siftup(array, 0, cmp);
  }
  return item;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  heap.replace(3).should.eql(1)
  heap.toArray().sort().should.eql([2,3,3,4,5])

describe &#x27;Heap#pushpop&#x27;, -&#x3e;
it &#x27;should behave like push() followed by pop()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.<span class="apidocCodeKeywordSpan">pushpop</span>(6).should.eql(1)
  heap.toArray().sort().should.eql([2..6])

describe &#x27;Heap#contains&#x27;, -&#x3e;
it &#x27;should return whether it contains the value&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.contains(v).should.be.true for v in [1..5]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.replace" id="apidoc.element.heap.replace">
        function <span class="apidocSignatureSpan">heap.</span>replace
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (array, item, cmp) {
  var returnitem;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  returnitem = array[0];
  array[0] = item;
  _siftup(array, 0, cmp);
  return returnitem;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  sorted = (heap.pop() until heap.empty())
  sorted.slice().sort().reverse().should.eql(sorted)

describe &#x27;Heap#replace&#x27;, -&#x3e;
it &#x27;should behave like pop() followed by push()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.<span class="apidocCodeKeywordSpan">replace</span>(3).should.eql(1)
  heap.toArray().sort().should.eql([2,3,3,4,5])

describe &#x27;Heap#pushpop&#x27;, -&#x3e;
it &#x27;should behave like push() followed by pop()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.pushpop(6).should.eql(1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.updateItem" id="apidoc.element.heap.updateItem">
        function <span class="apidocSignatureSpan">heap.</span>updateItem
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateItem = function (array, item, cmp) {
  var pos;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  pos = array.indexOf(item);
  if (pos === -1) {
    return;
  }
  _siftdown(array, 0, pos, cmp);
  return _siftup(array, pos, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  b = x: 2
  c = x: 3
  h = new Heap (m, n) -&#x3e; m.x - n.x
  h.push(a)
  h.push(b)
  h.push(c)
  c.x = 0
  h.<span class="apidocCodeKeywordSpan">updateItem</span>(c)
  h.pop().should.eql(c)
it &#x27;should return correct order when used statically&#x27;, -&#x3e;
  a = x: 1
  b = x: 2
  c = x: 3
  h = []
  cmp = (m, n) -&#x3e; m.x - n.x
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.heap.heap" id="apidoc.module.heap.heap">module heap.heap</a></h1>


    <h2>
        <a href="#apidoc.element.heap.heap.heap" id="apidoc.element.heap.heap.heap">
        function <span class="apidocSignatureSpan">heap.</span>heap
        <span class="apidocSignatureSpan">(cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Heap(cmp) {
  this.cmp = cmp != null ? cmp : defaultCmp;
  this.nodes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.heapify" id="apidoc.element.heap.heap.heapify">
        function <span class="apidocSignatureSpan">heap.heap.</span>heapify
        <span class="apidocSignatureSpan">(array, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heapify = function (array, cmp) {
  var i, _i, _j, _len, _ref, _ref1, _results, _results1;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  _ref1 = (function() {
    _results1 = [];
    for (var _j = 0, _ref = floor(array.length / 2); 0 &#x3c;= _ref ? _j &#x3c; _ref : _j &#x3e; _ref; 0 &#x3c;= _ref ? _j++ : _j--){ _results1.push
(_j); }
    return _results1;
  }).apply(this).reverse();
  _results = [];
  for (_i = 0, _len = _ref1.length; _i &#x3c; _len; _i++) {
    i = _ref1[_i];
    _results.push(_siftup(array, i, cmp));
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.nlargest" id="apidoc.element.heap.heap.nlargest">
        function <span class="apidocSignatureSpan">heap.heap.</span>nlargest
        <span class="apidocSignatureSpan">(array, n, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nlargest = function (array, n, cmp) {
  var elem, result, _i, _len, _ref;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  result = array.slice(0, n);
  if (!result.length) {
    return result;
  }
  heapify(result, cmp);
  _ref = array.slice(n);
  for (_i = 0, _len = _ref.length; _i &#x3c; _len; _i++) {
    elem = _ref[_i];
    heappushpop(result, elem, cmp);
  }
  return result.sort(cmp).reverse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
heap.pop(); // {foo: 1}
```

find 3 largest/smallest items in an array

```js
var array = [1, 3, 4, 2, 5];
Heap.<span class="apidocCodeKeywordSpan">nlargest</span>(array, 3);  // [5, 4, 3]
Heap.nsmallest(array, 3); // [1, 2, 3]
```

Document
--------

This module exposes only one object, namely the Heap class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.nsmallest" id="apidoc.element.heap.heap.nsmallest">
        function <span class="apidocSignatureSpan">heap.heap.</span>nsmallest
        <span class="apidocSignatureSpan">(array, n, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nsmallest = function (array, n, cmp) {
  var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  if (n * 10 &#x3c;= array.length) {
    result = array.slice(0, n).sort(cmp);
    if (!result.length) {
      return result;
    }
    los = result[result.length - 1];
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i &#x3c; _len; _i++) {
      elem = _ref[_i];
      if (cmp(elem, los) &#x3c; 0) {
        insort(result, elem, 0, null, cmp);
        result.pop();
        los = result[result.length - 1];
      }
    }
    return result;
  }
  heapify(array, cmp);
  _results = [];
  for (i = _j = 0, _ref1 = min(n, array.length); 0 &#x3c;= _ref1 ? _j &#x3c; _ref1 : _j &#x3e; _ref1; i = 0 &#x3c;= _ref1 ? ++_j : --_j) {
    _results.push(heappop(array, cmp));
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

find 3 largest/smallest items in an array

```js
var array = [1, 3, 4, 2, 5];
Heap.nlargest(array, 3);  // [5, 4, 3]
Heap.<span class="apidocCodeKeywordSpan">nsmallest</span>(array, 3); // [1, 2, 3]
```

Document
--------

This module exposes only one object, namely the Heap class.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.pop" id="apidoc.element.heap.heap.pop">
        function <span class="apidocSignatureSpan">heap.heap.</span>pop
        <span class="apidocSignatureSpan">(array, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function (array, cmp) {
  var lastelt, returnitem;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  lastelt = array.pop();
  if (array.length) {
    returnitem = array[0];
    array[0] = lastelt;
    _siftup(array, 0, cmp);
  } else {
    returnitem = lastelt;
  }
  return returnitem;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
push and pop

```js
var heap = new Heap();
heap.push(3);
heap.push(1);
heap.push(2);
heap.<span class="apidocCodeKeywordSpan">pop</span>(); // 1
```

custom comparison function

```js
var heap = new Heap(function(a, b) {
return a.foo - b.foo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.push" id="apidoc.element.heap.heap.push">
        function <span class="apidocSignatureSpan">heap.heap.</span>push
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (array, item, cmp) {
  if (cmp == null) {
    cmp = defaultCmp;
  }
  array.push(item);
  return _siftdown(array, 0, array.length - 1, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
-------


push and pop

```js
var heap = new Heap();
heap.<span class="apidocCodeKeywordSpan">push</span>(3);
heap.push(1);
heap.push(2);
heap.pop(); // 1
```

custom comparison function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.pushpop" id="apidoc.element.heap.heap.pushpop">
        function <span class="apidocSignatureSpan">heap.heap.</span>pushpop
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushpop = function (array, item, cmp) {
  var _ref;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  if (array.length &#x26;&#x26; cmp(array[0], item) &#x3c; 0) {
    _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
    _siftup(array, 0, cmp);
  }
  return item;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  heap.replace(3).should.eql(1)
  heap.toArray().sort().should.eql([2,3,3,4,5])

describe &#x27;Heap#pushpop&#x27;, -&#x3e;
it &#x27;should behave like push() followed by pop()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.<span class="apidocCodeKeywordSpan">pushpop</span>(6).should.eql(1)
  heap.toArray().sort().should.eql([2..6])

describe &#x27;Heap#contains&#x27;, -&#x3e;
it &#x27;should return whether it contains the value&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.contains(v).should.be.true for v in [1..5]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.replace" id="apidoc.element.heap.heap.replace">
        function <span class="apidocSignatureSpan">heap.heap.</span>replace
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (array, item, cmp) {
  var returnitem;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  returnitem = array[0];
  array[0] = item;
  _siftup(array, 0, cmp);
  return returnitem;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  sorted = (heap.pop() until heap.empty())
  sorted.slice().sort().reverse().should.eql(sorted)

describe &#x27;Heap#replace&#x27;, -&#x3e;
it &#x27;should behave like pop() followed by push()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.<span class="apidocCodeKeywordSpan">replace</span>(3).should.eql(1)
  heap.toArray().sort().should.eql([2,3,3,4,5])

describe &#x27;Heap#pushpop&#x27;, -&#x3e;
it &#x27;should behave like push() followed by pop()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.pushpop(6).should.eql(1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.updateItem" id="apidoc.element.heap.heap.updateItem">
        function <span class="apidocSignatureSpan">heap.heap.</span>updateItem
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateItem = function (array, item, cmp) {
  var pos;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  pos = array.indexOf(item);
  if (pos === -1) {
    return;
  }
  _siftdown(array, 0, pos, cmp);
  return _siftup(array, pos, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  b = x: 2
  c = x: 3
  h = new Heap (m, n) -&#x3e; m.x - n.x
  h.push(a)
  h.push(b)
  h.push(c)
  c.x = 0
  h.<span class="apidocCodeKeywordSpan">updateItem</span>(c)
  h.pop().should.eql(c)
it &#x27;should return correct order when used statically&#x27;, -&#x3e;
  a = x: 1
  b = x: 2
  c = x: 3
  h = []
  cmp = (m, n) -&#x3e; m.x - n.x
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.heap.heap.prototype" id="apidoc.module.heap.heap.prototype">module heap.heap.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.heap.heap.prototype.clear" id="apidoc.element.heap.heap.prototype.clear">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  return this.nodes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.clone" id="apidoc.element.heap.heap.prototype.clone">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var heap;
  heap = new Heap();
  heap.nodes = this.nodes.slice(0);
  return heap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
heap.pop()
heap.peek().should.eql(2)

describe &#x27;Heap#clone&#x27;, -&#x3e;
  it &#x27;should return a cloned heap&#x27;, -&#x3e;
a = new Heap
a.push(v) for v in [1..5]
b = a.<span class="apidocCodeKeywordSpan">clone</span>()
a.toArray().should.eql(b.toArray())

describe &#x27;Heap.nsmallest&#x27;, -&#x3e;
  it &#x27;should return exactly n elements when size() &#x3e;= n&#x27;, -&#x3e;
Heap.nsmallest([1..10], 3).should.eql([1..3])

array = [1,3,2,1,3,4,4,2,3,4,5,1,2,3,4,5,2,1,3,4,5,6,7,2]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.contains" id="apidoc.element.heap.heap.prototype.contains">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>contains
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (x) {
  return this.nodes.indexOf(x) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  heap.pushpop(6).should.eql(1)
  heap.toArray().sort().should.eql([2..6])

describe &#x27;Heap#contains&#x27;, -&#x3e;
it &#x27;should return whether it contains the value&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.<span class="apidocCodeKeywordSpan">contains</span>(v).should.be.true for v in [1..5]
  heap.contains(0).should.be.false
  heap.contains(6).should.be.false

describe &#x27;Heap#peek&#x27;, -&#x3e;
it &#x27;should return the top value&#x27;, -&#x3e;
  heap = new Heap
  heap.push(1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.copy" id="apidoc.element.heap.heap.prototype.copy">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>copy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function () {
  var heap;
  heap = new Heap();
  heap.nodes = this.nodes.slice(0);
  return heap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.empty" id="apidoc.element.heap.heap.prototype.empty">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function () {
  return this.nodes.length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Heap = require &#x27;..&#x27;
{random} = Math

describe &#x27;Heap#push, Heap#pop&#x27;, -&#x3e;
it &#x27;should sort an array using push and pop&#x27;, -&#x3e;
  heap = new Heap
  heap.push(random()) for i in [1..10]
  sorted = (heap.pop() until heap.<span class="apidocCodeKeywordSpan">empty</span>())
  sorted.slice().sort().should.eql(sorted)

it &#x27;should work with custom comparison function&#x27;, -&#x3e;
  cmp = (a, b) -&#x3e;
    return -1 if a &#x3e; b
    return 1 if a &#x3c; b
    0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.front" id="apidoc.element.heap.heap.prototype.front">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>front
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">front = function () {
  return this.nodes[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.has" id="apidoc.element.heap.heap.prototype.has">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>has
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (x) {
  return this.nodes.indexOf(x) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.heapify" id="apidoc.element.heap.heap.prototype.heapify">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>heapify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heapify = function () {
  return heapify(this.nodes, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.insert" id="apidoc.element.heap.heap.prototype.insert">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>insert
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (x) {
  return heappush(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.peek" id="apidoc.element.heap.heap.prototype.peek">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  return this.nodes[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  heap.contains(0).should.be.false
  heap.contains(6).should.be.false

describe &#x27;Heap#peek&#x27;, -&#x3e;
it &#x27;should return the top value&#x27;, -&#x3e;
  heap = new Heap
  heap.push(1)
  heap.<span class="apidocCodeKeywordSpan">peek</span>().should.eql(1)
  heap.push(2)
  heap.peek().should.eql(1)
  heap.pop()
  heap.peek().should.eql(2)

describe &#x27;Heap#clone&#x27;, -&#x3e;
it &#x27;should return a cloned heap&#x27;, -&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.pop" id="apidoc.element.heap.heap.prototype.pop">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  return heappop(this.nodes, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
push and pop

```js
var heap = new Heap();
heap.push(3);
heap.push(1);
heap.push(2);
heap.<span class="apidocCodeKeywordSpan">pop</span>(); // 1
```

custom comparison function

```js
var heap = new Heap(function(a, b) {
return a.foo - b.foo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.push" id="apidoc.element.heap.heap.prototype.push">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>push
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (x) {
  return heappush(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
-------


push and pop

```js
var heap = new Heap();
heap.<span class="apidocCodeKeywordSpan">push</span>(3);
heap.push(1);
heap.push(2);
heap.pop(); // 1
```

custom comparison function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.pushpop" id="apidoc.element.heap.heap.prototype.pushpop">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>pushpop
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushpop = function (x) {
  return heappushpop(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  heap.replace(3).should.eql(1)
  heap.toArray().sort().should.eql([2,3,3,4,5])

describe &#x27;Heap#pushpop&#x27;, -&#x3e;
it &#x27;should behave like push() followed by pop()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.<span class="apidocCodeKeywordSpan">pushpop</span>(6).should.eql(1)
  heap.toArray().sort().should.eql([2..6])

describe &#x27;Heap#contains&#x27;, -&#x3e;
it &#x27;should return whether it contains the value&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.contains(v).should.be.true for v in [1..5]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.replace" id="apidoc.element.heap.heap.prototype.replace">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>replace
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (x) {
  return heapreplace(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  sorted = (heap.pop() until heap.empty())
  sorted.slice().sort().reverse().should.eql(sorted)

describe &#x27;Heap#replace&#x27;, -&#x3e;
it &#x27;should behave like pop() followed by push()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.<span class="apidocCodeKeywordSpan">replace</span>(3).should.eql(1)
  heap.toArray().sort().should.eql([2,3,3,4,5])

describe &#x27;Heap#pushpop&#x27;, -&#x3e;
it &#x27;should behave like push() followed by pop()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.pushpop(6).should.eql(1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.size" id="apidoc.element.heap.heap.prototype.size">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  return this.nodes.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.toArray" id="apidoc.element.heap.heap.prototype.toArray">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  return this.nodes.slice(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  sorted.slice().sort().reverse().should.eql(sorted)

describe &#x27;Heap#replace&#x27;, -&#x3e;
it &#x27;should behave like pop() followed by push()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.replace(3).should.eql(1)
  heap.<span class="apidocCodeKeywordSpan">toArray</span>().sort().should.eql([2,3,3,4,5])

describe &#x27;Heap#pushpop&#x27;, -&#x3e;
it &#x27;should behave like push() followed by pop()&#x27;, -&#x3e;
  heap = new Heap
  heap.push(v) for v in [1..5]
  heap.pushpop(6).should.eql(1)
  heap.toArray().sort().should.eql([2..6])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.top" id="apidoc.element.heap.heap.prototype.top">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>top
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">top = function () {
  return this.nodes[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.heap.heap.prototype.updateItem" id="apidoc.element.heap.heap.prototype.updateItem">
        function <span class="apidocSignatureSpan">heap.heap.prototype.</span>updateItem
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateItem = function (x) {
  return updateItem(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  b = x: 2
  c = x: 3
  h = new Heap (m, n) -&#x3e; m.x - n.x
  h.push(a)
  h.push(b)
  h.push(c)
  c.x = 0
  h.<span class="apidocCodeKeywordSpan">updateItem</span>(c)
  h.pop().should.eql(c)
it &#x27;should return correct order when used statically&#x27;, -&#x3e;
  a = x: 1
  b = x: 2
  c = x: 3
  h = []
  cmp = (m, n) -&#x3e; m.x - n.x
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
